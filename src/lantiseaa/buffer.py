import os
import csv
import copy
import errno
import pandas as pd
import pymc3 as pm
from sklearn.externals import joblib
from abc import ABC, abstractmethod


class BaseBuffer(ABC):
    ''' Base class for Buffer classes which store/save and retrieve/read data.

    ...

    Methods
    -------
    save_record(self, genre, type_name, name, key, fold_number, train_test, surfix)
        Save a record for the buffering/saving of a data

    read_records()
        Read records for the data buffered/saved

    save_result(self, df, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None)
        Save a piece of result
    
    read_result(self, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None)
        Read the requested piece of result
    
    save_class(self, c, method_name, class_name, subclass_name=None, fold_number=None, surfix=None)
        Save a class
    
    read_class(self, method_name, class_name, subclass_name=None, fold_number=None, surfix=None)
        Read the requested class

    save_bayesian_estimation_trace(self, trace, group1_name, group2_name, surfix=None)
        Save a trace generated by bayesian estimation

    read_bayesian_estimation_trace(self, group1_name, group2_name, surfix=None)
        Read the requested trace
    
    save_feature_set(self, df, method_name, key='X', fold_number=None, train_test=None, surfix=None)
        Save a set of features
    
    read_feature_set(self, method_name, key='X', fold_number=None, train_test=None, surfix=None)
        Read the request set of features

    save_intermediate_result(self, df, method_name, key, fold_number=None, train_test=None, surfix=None)
        Save a piece of intermediate result generated during computation

    read_intermediate_result(self, method_name, key, fold_number=None, train_test=None, surfix=None)
        Read the request piece of intermediate result

    save_feature_relevance_table(self, relevance_table, method_name, key='feature_relevance_table', fold_number=None, surfix=None)
        Save a feature relevance table (relevant features) calculated (selected) by the feature extractor

    read_feature_relevance_table(self, method_name, key='feature_relevance_table', fold_number=None, surfix=None)
        Read the requested feature relevance table (relevant features)

    save_prediction(self, pred_df, method_name, key='prediction', fold_number=None, train_test=None, surfix=None)
        Save predictions of target labels made on the data/features by a classifier

    read_prediction(self, method_name, key='prediction', fold_number=None, train_test=None, surfix=None)
        Read the requested predictions of target labels

    save_class_attribute(self, attribute_df, method_name, class_name, attribute_name, fold_number=None, surfix=None)
        Save an attribute of a class

    read_class_attribute(self, method_name, class_name, attribute_name, fold_number=None, surfix=None)
        Read the requested attribute of a class

    save_evaluation_score(self, score_df, method_name, surfix=None)
        Save evaluation scores obtained from a method

    read_evaluation_score(self, method_name, surfix=None)
        Read the requested evaluation scores obtained from a method
        
    '''

    def __init__(self):
        super().__init__()


    @abstractmethod
    def save_record(self, genre, type_name, name, key, fold_number, train_test, surfix):
        pass

    @abstractmethod
    def read_records(self):
        pass
    
    @abstractmethod
    def save_result(self, df, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None):
        pass

    @abstractmethod
    def read_result(self, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None):
        pass

    @abstractmethod
    def save_class(self, c, method_name, class_name, subclass_name=None, fold_number=None, surfix=None):
        pass

    @abstractmethod
    def read_class(self, method_name, class_name, subclass_name=None, fold_number=None, surfix=None):
        pass
    
    @abstractmethod
    def save_bayesian_estimation_trace(self, trace, group1_name, group2_name, surfix=None):
        pass

    @abstractmethod
    def read_bayesian_estimation_trace(self, group1_name, group2_name, surfix=None):
        pass


    def save_feature_set(self, df, method_name, key='X', fold_number=None, train_test=None, surfix=None):
        self.save_result(df, key, data_type='feature', data_name=method_name, fold_number=fold_number, train_test=train_test, surfix=surfix)


    def read_feature_set(self, method_name, key='X', fold_number=None, train_test=None, surfix=None):
        return self.read_result(key, data_type='feature', data_name=method_name, fold_number=fold_number, train_test=train_test, surfix=surfix)


    def save_intermediate_result(self, df, method_name, key, fold_number=None, train_test=None, surfix=None):
        self.save_result(df, key, data_type='intermediate_result', data_name=method_name, fold_number=fold_number, train_test=train_test, 
                         surfix=surfix)


    def read_intermediate_result(self, method_name, key, fold_number=None, train_test=None, surfix=None):
        return self.read_result(key, data_type='intermediate_result', data_name=method_name, fold_number=fold_number, train_test=train_test, 
                                    surfix=surfix)


    def save_feature_relevance_table(self, relevance_table, method_name, key='feature_relevance_table', fold_number=None, surfix=None):
        self.save_result(relevance_table, key, data_type='result', data_name=method_name, fold_number=fold_number, train_test=None, surfix=surfix)


    def read_feature_relevance_table(self, method_name, key='feature_relevance_table', fold_number=None, surfix=None):
        return self.read_result(key, data_type='result', data_name=method_name, fold_number=fold_number, train_test=None, surfix=surfix)


    def save_prediction(self, pred_df, method_name, key='prediction', fold_number=None, train_test=None, surfix=None):
        self.save_result(pred_df, key, data_type='result', data_name=method_name, fold_number=fold_number, train_test=train_test, surfix=surfix)


    def read_prediction(self, method_name, key='prediction', fold_number=None, train_test=None, surfix=None):
        return self.read_result(key, data_type='result', data_name=method_name, fold_number=fold_number, train_test=train_test, surfix=surfix)


    def save_class_attribute(self, attribute_df, method_name, class_name, attribute_name, fold_number=None, surfix=None):
        key = '{}__{}'.format(class_name, attribute_name)
        self.save_result(attribute_df, key, data_type='class_attribute', data_name=method_name, fold_number=fold_number, train_test=None, surfix=surfix)


    def read_class_attribute(self, method_name, class_name, attribute_name, fold_number=None, surfix=None):
        key = '{}__{}'.format(class_name, attribute_name)
        return self.read_result(key, data_type='class_attribute', data_name=method_name, fold_number=fold_number, train_test=None, surfix=surfix)


    def save_evaluation_score(self, score_df, method_name, surfix=None):
        key = 'cv_scores__{}'.format(method_name)
        self.save_result(score_df, key, data_type='score', data_name=None, fold_number=None, 
                             train_test=None, surfix=surfix)


    def read_evaluation_score(self, method_name, surfix=None):
        key = 'cv_scores__{}'.format(method_name)
        return self.read_result(key, data_type='score', data_name=None, fold_number=None, 
                                    train_test=None, surfix=surfix)



class LocalBuffer(BaseBuffer):
    '''The buffer that saves/reads files into/from computer's hard drive.

    The LocalBuffer creates a few folders (data, results, figures, and classes) under the specified project 
    path and save data into subfolders of a specified name (if given) under these folders.

    For example, for a project at "../project_lantiseaa/" and with specified subfolder name "trail_1", the 
    project structure will be something like the following (if all folders are used - if a folder is not 
    used, it will not appear on the disk):

    project_lantiseaa
    |-- data
    |  |-- trail_1
    |     |-- data1.csv
    |-- results
    |  |-- trail_1
    |     |-- result1.hdf
    |     |-- result2.hdf
    |-- figures
    |  |-- trail_1
    |     |-- fig1.png
    |-- classes
    |  |-- trail_1
    |     |-- class1.pkl

    '''

    def __init__(self, project_path=None, subfolder=''):
        super().__init__()
        self.reset_path(project_path, subfolder)


    def reset_path(self, project_path=None, subfolder=''):
        """Reset the default project path and the subfolder name for saving/reading data and results

        If the project_path is not given, the parent of the 'LanTiSEAA' folder will be set as the 
        project_path in default. If the subfolder is not given, all savings/readings will be done from 
        the root 'data', 'results', 'figure' and 'classes' folders in default (this can be override on each save/read method).

        Parameters
        ----------
        project_path : str, optional
            The root path of the project where the data and results will be stored in (default is None).
        
        subfolder : str, optional
            The subfolder under the root 'data', 'results', 'figures' and 'classes' folders where the data 
            and results will be saved to (default is an empty string '').

        """
        if project_path == None:
            # Assume this file is under '../workspace/LanTiSEAA/src/lantiseaa', in default set '../workspace' as the project path
            self.project_path = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                             '../../..')
                                )
        else:
            if os.path.isdir(project_path):
                self.project_path = project_path
            else:
                raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), project_path)
        
        self.subfolder = subfolder


    def project(self, filename, folder=''):
        """Return absolute path of file within folder hierarchy"""
        return os.path.join(self.project_path, folder, filename)


    def data(self, filename, subfolder=''):
        """Return absolute path of file within the data folder"""
        return self.project(filename, folder=os.path.join('data', subfolder))


    def results(self, filename, subfolder=''):
        """Return absolute path of file within the results folder"""
        return self.project(filename, folder=os.path.join('results', subfolder))


    def figures(self, filename, subfolder=''):
        """Return absolute path of file within the figures folder"""
        return self.project(filename, folder=os.path.join('figures', subfolder))

    
    def classes(self, filename, subfolder=''):
        """Return absolute path of file within the classes folder"""
        return self.project(filename, folder=os.path.join('classes', subfolder))


    def save_record(self, genre, type_name, name, key, fold_number, train_test, surfix):
        '''Append a record in "records.csv" under results folder.

        Parameters
        ----------
        genre : str
            "result", "class" or "traces"
        
        type_name : str
            'data_type' in save_result, 'method_name' in save_class or 'file_name' in save_bayesian_estimation_trace

        name : str
            'data_name' in save_result or 'class_name' in save_class

        key : str
            'key' in save_result or 'subclass_name' in save_class

        fold_number : int or str
            'fold_number' in save_result and save_class
        
        train_test : str
            'train_test' in save_result

        surfix : str
            'surfix' in save_result, save_class and save_bayesian_estimation_trace

        '''
        records = self.results("records.csv", subfolder=self.subfolder)
        if not os.path.exists(records):
            with open(records, 'w', newline='') as csvfile:
                csv.writer(csvfile, delimiter=',', quotechar='|').writerow(['Genre', 'Type/Method', 'Data/Class', 'Key/Subclass', 'Fold', 'Train/Test', 'Surfix'])

        with open(records, 'a', newline='') as csvfile:
            csv.writer(csvfile, delimiter=',', quotechar='|').writerow([genre, type_name, name, key, fold_number, train_test, surfix])


    def read_records(self):
        '''Read the records stored in "records.csv" under results folder.'''
        records = self.results("records.csv", subfolder=self.subfolder)
        if not os.path.exists(records):
            return None
        else:
            return pd.read_csv(records).sort_values(by=['Genre', 'Type/Method', 'Data/Class', 'Key/Subclass', 'Fold', 'Train/Test', 'Surfix']).reset_index(drop=True)


    def save_result(self, df, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None):
        '''Save result data under the results folder.

        Parameters
        ----------
        df : pandas.DataFrame
            the data to be saved
        
        key : str
            key to identify the data
        
        data_type : str, optional
            data_type to identify the data

        data_name : str, optional
            data_name to identify the data

        fold_number : int or str, optional
            the fold the data came from, also to identify the data

        train_test : str, optional
            train or test where the data came from, also to identify the data

        surfix : str, optional
            surfix to add to the end of the file name, also to identify the data

        '''
        # create the directory if not exist
        if not os.path.isdir(self.results('', self.subfolder)):
            os.mkdir(self.results('', self.subfolder))

        if data_name is not None:
            data_type += '__{}'.format(data_name)

        if fold_number is not None:
            key += '__fold_{}'.format(fold_number)
        if train_test is not None:
            key += '__{}'.format(train_test)
        if surfix is not None:
            key += '__{}'.format(surfix)

        df.to_hdf(self.results('{}.hdf'.format(data_type), self.subfolder), key)
        self.save_record(genre='result', type_name=data_type, name=data_name, key=key, fold_number=fold_number, train_test=train_test, surfix=surfix)


    def read_result(self, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None):
        '''Read result data from under the results folder.

        Parameters
        ----------
        key : str
            key to identify the data
        
        data_type : str, optional
            data_type to identify the data (default is 'data')

        data_name : str, optional
            data_name to identify the data (default is None)

        fold_number : int or str, optional
            the fold the data came from, also to identify the data (default is None)

        train_test : str, optional
            train or test where the data came from, also to identify the data (default is None)

        surfix : str, optional
            surfix to add to the end of the file name, also to identify the data (default is None)

        '''
        if data_name is not None:
            data_type += '__{}'.format(data_name)

        if fold_number is not None:
            key += '__fold_{}'.format(fold_number)
        if train_test is not None:
            key += '__{}'.format(train_test)
        if surfix is not None:
            key += '__{}'.format(surfix)
        
        return pd.read_hdf(self.results('{}.hdf'.format(data_type), self.subfolder), key)


    def save_class(self, c, method_name, class_name, subclass_name=None, fold_number=None, surfix=None):
        '''Save class under the classes folder.

        Parameters
        ----------
        c : object
            the class object to be saved
        
        method_name : str
            the name of the method (e.g. tokenfreqseq) the class object obtained from, also to identify the class object

        class_name : str
            the name of the class object, to identify the class object

        subclass_name : str
            the name of the subclass (if the class is an object comtained by another object), to identify the subclass

        fold_number : int or str, optional
            the fold the class object came from, also to identify the class object (default is None)

        surfix : str, optional
            surfix to add to the end of the file name, also to identify the class object (default is None)

        '''
        # create the directory if not exist
        if not os.path.isdir(self.classes('', self.subfolder)):
            os.mkdir(self.classes('', self.subfolder))
        
        filename = '{}__{}'.format(method_name, class_name)

        if subclass_name is not None:
            filename += '__{}'.format(subclass_name)
        if fold_number is not None:
            filename += '__fold_{}'.format(fold_number)
        if surfix is not None:
            filename += '__{}'.format(surfix)

        joblib.dump(c, self.classes(filename, self.subfolder))
        self.save_record(genre='class', type_name=method_name, name=class_name, key=subclass_name, fold_number=fold_number, train_test=None, surfix=surfix)


    def read_class(self, method_name, class_name, subclass_name=None, fold_number=None, surfix=None):
        '''Read class from under the classes folder.

        Parameters
        ----------
        method_name : str
            the name of the method (e.g. tokenfreqseq) the class object obtained from, also to identify the class object

        class_name : str
            the name of the class object, to identify the class object

        subclass_name : str
            the name of the subclass (if the class is an object comtained by another object), to identify the subclass

        fold_number : int or str, optional
            the fold the class object came from, also to identify the class object (default is None)

        surfix : str, optional
            surfix to add to the end of the file name, also to identify the class object (default is None)

        '''
        filename = '{}__{}'.format(method_name, class_name)

        if subclass_name is not None:
            filename += '__{}'.format(subclass_name)
        if fold_number is not None:
            filename += '__fold_{}'.format(fold_number)
        if surfix is not None:
            filename += '__{}'.format(surfix)

        return joblib.load(self.classes(filename, self.subfolder))

    
    def save_bayesian_estimation_trace(self, trace, group1_name, group2_name, surfix=None):
        '''Save the bayesian estimation trace under the classes folder.

        Parameters
        ----------
        trace : object
            the trace object to be saved
        
        group1_name : str
            the name of group1 in the bayesian estimation, also to identify the trace object

        group2_name : str
            the name of group2 in the bayesian estimation, also to identify the trace object

        surfix : str, optional
            surfix to add to the end of the file name, also to identify the trace object (default is None)

        '''
        filename = 'traces__{}__{}'.format(group1_name, group2_name)

        if surfix is not None:
            filename += '__{}'.format(surfix)
        
        joblib.dump(trace, self.classes(filename, self.subfolder))
        self.save_record(genre='traces', type_name=filename, name=None, key=None, fold_number=None, train_test=None, surfix=surfix)


    def read_bayesian_estimation_trace(self, group1_name, group2_name, surfix=None):
        '''Read the bayesian estimation trace from under the classes folder.

        Parameters
        ----------
        group1_name : str
            the name of group1 in the bayesian estimation, also to identify the trace object

        group2_name : str
            the name of group2 in the bayesian estimation, also to identify the trace object

        surfix : str, optional
            surfix to add to the end of the file name, also to identify the trace object (default is None)

        '''
        filename = 'traces__{}__{}'.format(group1_name, group2_name)

        if surfix is not None:
            filename += '__{}'.format(surfix)
        
        return joblib.load(self.classes(filename, self.subfolder))



class MemoryBuffer(BaseBuffer):
    '''The buffer that stores/retrieves data into/from computer's memory.'''

    def __init__(self):
        super().__init__()
        self.records_ = None
        self.results_ = {}
        self.classes_ = {}
        self.traces_ = {}


    def save_record(self, genre, type_name, name, key, fold_number, train_test, surfix):
        new_record = pd.DataFrame([[genre, type_name, name, key, fold_number, train_test, surfix]], 
                                  columns=['Genre', 'Type/Method', 'Data/Class', 'Key/Subclass', 'Fold', 'Train/Test', 'Surfix'])
        if self.records_ is None:
            self.records_ = new_record
        else:
            self.records_.append(new_record, ignore_index=True)


    def read_records(self):
        return self.records_.sort_values(by=['Genre', 'Type/Method', 'Data/Class', 'Key/Subclass', 'Fold', 'Train/Test', 'Surfix']).reset_index(drop=True)
    

    def save_result(self, df, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None):
        if data_name is not None:
            data_type += '__{}'.format(data_name)
        if data_type not in self.results_.keys():
            self.results_.update({data_type: {}})

        if fold_number is not None:
            key += '__fold_{}'.format(fold_number)
        if train_test is not None:
            key += '__{}'.format(train_test)
        if surfix is not None:
            key += '__{}'.format(surfix)
        
        self.results_[data_type].update({key: df})
        self.save_record(genre='result', type_name=data_type, name=data_name, key=key, fold_number=fold_number, train_test=train_test, surfix=surfix)


    def read_result(self, key, data_type='data', data_name=None, fold_number=None, train_test=None, surfix=None):
        if data_name is not None:
            data_type += '__{}'.format(data_name)

        if fold_number is not None:
            key += '__fold_{}'.format(fold_number)
        if train_test is not None:
            key += '__{}'.format(train_test)
        if surfix is not None:
            key += '__{}'.format(surfix)
        
        return self.results_[data_type][key]


    def save_class(self, c, method_name, class_name, subclass_name=None, fold_number=None, surfix=None):
        key = '{}__{}'.format(method_name, class_name)

        if subclass_name is not None:
            key += '__{}'.format(subclass_name)
        if fold_number is not None:
            key += '__fold_{}'.format(fold_number)
        if surfix is not None:
            key += '__{}'.format(surfix)

        self.classes_.update({key: copy.deepcopy(c)})
        self.save_record(genre='class', type_name=method_name, name=class_name, key=subclass_name, fold_number=fold_number, train_test=None, surfix=surfix)


    def read_class(self, method_name, class_name, subclass_name=None, fold_number=None, surfix=None):
        key = '{}__{}'.format(method_name, class_name)

        if subclass_name is not None:
            key += '__{}'.format(subclass_name)
        if fold_number is not None:
            key += '__fold_{}'.format(fold_number)
        if surfix is not None:
            key += '__{}'.format(surfix)

        return self.classes_[key]


    def save_bayesian_estimation_trace(self, trace, group1_name, group2_name, surfix=None):
        key = '{}__{}'.format(group1_name, group2_name)

        if surfix is not None:
            key += '__{}'.format(surfix)
        
        self.traces_.update({key: copy.deepcopy(trace)})
        self.save_record(genre='traces', type_name=key, name=None, key=None, fold_number=None, train_test=None, surfix=surfix)


    def read_bayesian_estimation_trace(self, group1_name, group2_name, surfix=None):
        key = '{}__{}'.format(group1_name, group2_name)

        if surfix is not None:
            key += '__{}'.format(surfix)
        
        return self.traces_[key]
